<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>apply/call/bind 一网打尽</title>
    <url>/2020/04/28/apply-call-bind/</url>
    <content><![CDATA[<p>首先，这三个方法是用来改变 this 指向的，接下来我们看一下它们的异同。</p>
<a id="more"></a>

<h1 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h1><ul>
<li>调用一个对象的一个方法，用另一个对象替换当前对象。例如：<code>B.apply(A, arguments)</code>; 即 A 对象应用 B 对象的方法。</li>
<li>要注意的是第一个参数，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，而其他原始值则会被相应的包装对象（wrapper object）所替代。</li>
</ul>
<h2 id="如何实现一个apply"><a href="#如何实现一个apply" class="headerlink" title="如何实现一个apply"></a>如何实现一个apply</h2><p>回顾一下 apply 的效果，我们可以大致按以下思路走</p>
<ol>
<li>实现第一个参数的功能，改变 this 指向</li>
<li>实现第二个参数的功能。第二个参数是作为调用函数的参数</li>
<li>返回值：使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。</li>
</ol>
<p>接下来，我们按以上思路来实现一下。</p>
<h3 id="第一步，绑定-this"><a href="#第一步，绑定-this" class="headerlink" title="第一步，绑定 this"></a>第一步，绑定 this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.apply(o);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与下面代码的功能类似（假设对象o中预先不存在名为m的属性）。</span></span><br><span class="line">o.m=f; <span class="comment">//将f存储为o的临时方法</span></span><br><span class="line">o.m(); <span class="comment">//调用它，不传入参数</span></span><br><span class="line"><span class="keyword">delete</span> o.m;<span class="comment">//将临时方法删除</span></span><br></pre></td></tr></table></figure>
<p>(以上代码摘录自犀牛书)<br>依样画葫芦，我们可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line">    context.__fn()</span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二步，给函数传递参数"><a href="#第二步，给函数传递参数" class="headerlink" title="第二步，给函数传递参数"></a>第二步，给函数传递参数</h3><p>接下来我们想办法实现一下 apply 的第二个参数。其实我最快想到的是 ES6 的方法。用<code>...</code> 直接展开就行了。不过 apply 才 ES3😂，还是再想想老的办法吧。</p>
<p>难点是这个数组的长度是不确定的，也就是说我们没办法很准确地给函数一个个传参。我们所能做的处理也就是把<code>arguments</code>转成字符串形式<code>&#39;arguments[1], arguments[2], ...&#39;</code>。那么如何让字符串能运行起来呢？？答案就是 <code>eval</code>！</p>
<p>稍稍总结一下, 目前想到的 2 种方法</p>
<blockquote>
<ol>
<li>es6。<code>context.__fn(...arguments)</code></li>
<li>把 arguments 转换成string，放到 eval 里面运行 <code>eval(&#39;context.__fn(&#39;+ &#39;arguments[1], arguments[2]&#39; +&#39;)&#39;)</code></li>
</ol>
</blockquote>
<p>以下是第二种思路的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, others</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// args: 'others[0], others[1], others[2], ...'</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = others.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'others['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'context.__fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步，返回值"><a href="#第三步，返回值" class="headerlink" title="第三步，返回值"></a>第三步，返回值</h3><p>返回函数调用后的结果就行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, others</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// args: 'others[0], others[1], others[2], ...'</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = others.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'others['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'context.__fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更进一步，严格模式下的-this"><a href="#更进一步，严格模式下的-this" class="headerlink" title="更进一步，严格模式下的 this"></a>更进一步，严格模式下的 this</h3><p>我们之前有提到：第一个参数，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，而其他原始值则会被相应的包装对象（wrapper object）所替代</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, others</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> argsArray === <span class="string">'undefined'</span> || argsArray === <span class="literal">null</span>) &#123;</span><br><span class="line">        context = <span class="built_in">window</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// context 是一个 object</span></span><br><span class="line">    context = <span class="keyword">new</span> <span class="built_in">Object</span>(context)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = others.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'others['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'context.__fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="再进一步，确保-fn-不存在"><a href="#再进一步，确保-fn-不存在" class="headerlink" title="再进一步，确保 __fn 不存在"></a>再进一步，确保 __fn 不存在</h3><p>我们之前的代码都是建立在 <code>__fn</code> 不存在的情况下，那么万一存在呢？因此我们接下来就要找一个 <code>context</code> 中没有存在过的属性。<br>🤔我们很快可以想到 ES6 的 symbol。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 像这样</span></span><br><span class="line"><span class="keyword">var</span> __fn = <span class="keyword">new</span> <span class="built_in">Symbol</span>()</span><br><span class="line">context[__fn] = <span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>🤔如果不用 ES6，那么另一种方法，是根据 <a href="https://juejin.im/post/5bf6c79bf265da6142738b29#heading-4">这篇文章</a>中提到的，自己用 Math.random() 模拟实现独一无二的 key。面试时可以直接用生成时间戳即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 UUID 通用唯一识别码</span></span><br><span class="line"><span class="comment">// 大概生成 这样一串 '18efca2d-6e25-42bf-a636-30b8f9f2de09'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateUUID</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, random;</span><br><span class="line">    <span class="keyword">var</span> uuid = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        random = <span class="built_in">Math</span>.random() * <span class="number">16</span> | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">8</span> || i === <span class="number">12</span> || i === <span class="number">16</span> || i === <span class="number">20</span>) &#123;</span><br><span class="line">            uuid += <span class="string">'-'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uuid += (i === <span class="number">12</span> ? <span class="number">4</span> : (i === <span class="number">16</span> ? (random &amp; <span class="number">3</span> | <span class="number">8</span>) : random))</span><br><span class="line">            .toString(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单实现</span></span><br><span class="line"><span class="comment">// '__' + new Date().getTime();</span></span><br></pre></td></tr></table></figure>
<p>如果这个key万一这对象中还是有，为了保险起见，可以做一次缓存操作(就是先把之前的值保存起来)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 像这样</span></span><br><span class="line"><span class="keyword">var</span> originalvalue = context.__fn</span><br><span class="line"><span class="keyword">var</span> hasOriginalValue = context.hasOwnProperty(<span class="string">'__fn'</span>)</span><br><span class="line">context.__fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hasOriginalValue)&#123;</span><br><span class="line">    context.__fn = originalvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><ul>
<li><p>和 apply 的作用是一样的，只是 <code>call()</code> 方法接受的是一个参数列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p>
</li>
<li><p>例如 <code>func.apply(obj, [1,2])</code> 相当于 <code>func.call(obj, 1, 2)</code></p>
</li>
</ul>
<h2 id="实现一个-call"><a href="#实现一个-call" class="headerlink" title="实现一个 call"></a>实现一个 call</h2><p>思路和 apply 一样。唯一区别就在于参数形式。我们按照 call 的要求来处理参数就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 我们从 arguments[1] 开始拼就好了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'context.__fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><p>我们常将 bind 和以上两个方法区分开，是因为 bind 是 ECMAScript 5 中的方法，且除了将函数绑定至一个对象外还多了一些特点。</p>
<ul>
<li><p><strong>bind() 方法创建一个新的函数</strong>，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的初始参数，供调用时使用。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func.apply(obj, [<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">func.call(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> boundFun = func.bind(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">boundFun()</span><br><span class="line"><span class="comment">// 也可以这样</span></span><br><span class="line"><span class="keyword">var</span> boundFun = func.bind(obj, <span class="number">1</span>)</span><br><span class="line">boundFun(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>绑定函数也可以使用 new 运算符构造</strong>，它会表现为目标函数已经被构建完毕了似的。提供的 this 值会被忽略，但前置参数仍会提供给模拟函数。</p>
</li>
</ul>
<h2 id="实现一个-bind"><a href="#实现一个-bind" class="headerlink" title="实现一个 bind"></a>实现一个 bind</h2><p>我们还是先大致思考一下该怎么做：</p>
<ol>
<li>实现第一个参数的功能，改变 this 指向。这个和 apply/call 是一样的。</li>
<li>返回值：返回一个新的函数。</li>
<li>实现其它参数。其它参数将作为新函数的初始参数，供调用时使用。这个和 call 有些相似。</li>
<li>使用 new 操作符时，应该忽略第一个参数</li>
</ol>
<p>后续的步骤我会用 apply/call 来实现bind。如果不想直接用 apply/call，也可以按照上文先实现一个 apply/call。</p>
<h3 id="第一步，返回一个绑定了-this-的新函数"><a href="#第一步，返回一个绑定了-this-的新函数" class="headerlink" title="第一步，返回一个绑定了 this 的新函数"></a>第一步，返回一个绑定了 this 的新函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二步，给新函数设定初始参数"><a href="#第二步，给新函数设定初始参数" class="headerlink" title="第二步，给新函数设定初始参数"></a>第二步，给新函数设定初始参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 bind 函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> initialArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个绑定好 this 的新函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个是调用新函数时传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> boundArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 最终的参数应该是初始参数+新函数的参数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三步，作为构造函数调用时，忽略要绑定的-this"><a href="#第三步，作为构造函数调用时，忽略要绑定的-this" class="headerlink" title="第三步，作为构造函数调用时，忽略要绑定的 this"></a>第三步，作为构造函数调用时，忽略要绑定的 this</h3><p>这里的难点是怎么知道是由 new 调用的。<br>先说一下答案吧</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如有以下函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 <code>var gioia = new Person()</code> 来说<br>使用 new 时，this 会指向 gioia，并且 gioia 是 Person 的实例。<br>因此，如果 <code>this instance Person</code>，就说明是 new 调用的</p>
</blockquote>
<p>new 这一部分这里先不展开讲，有兴趣的可以看一下 <a href="https://github.com/mqyqingfeng/Blog/issues/13">JavaScript深入之new的模拟实现</a><br>接下来我们可以写代码了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 bind 函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> initialArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个绑定好 this 的新函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Bound</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个是调用新函数时传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> boundArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 最终的参数应该是初始参数+新函数的参数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> instance Bound ? <span class="keyword">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bound.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">    <span class="keyword">return</span> Bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><a href="https://juejin.im/post/5bf6c79bf265da6142738b29">面试官问：能否模拟实现JS的call和apply方法</a></li>
<li><a href="https://juejin.im/post/5907eb99570c3500582ca23c">JavaScript深入之call和apply的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/12">JavaScript深入之bind的模拟实现</a></li>
</ul>
]]></content>
      <tags>
        <tag>this</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>写一个简易的打包工具</title>
    <url>/2020/04/30/miniwebpack/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知道有没有人和我一样，不管看了几遍文档，还是不会自己写 webpack，只能在别人写的配置上修修补补，更别提什么优化了。<br>于是我痛定思痛，决定从源头上解决这个问题！为了更好地应用 webpack，我们应该了解它背后的工作原理。<br>因此，我阅读了 <a href="https://github.com/ronami/minipack/blob/master/src/minipack.js">miniwebpack</a> 这个仓库。这个仓库实现了一个最简单的打包工具。接下来我会按照我的理解来解释一下怎么实现一个简单的打包工具</p>
<a id="more"></a>

<h1 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h1><ol>
<li>代码处理。我们平常写代码的时候，用的可能是ES6、ES7等高版本的语法，我们需要将它们转换成浏览器能运行的语法</li>
<li>打包。需要根据一个 entry 来输出一个 output，我们通过维护一个依赖关系图来解决这个问题</li>
</ol>
<pre class="mermaid">graph LR
A[entry] --> |解析代码| B[AST]
B --> |生成| C[浏览器可用代码]
B --> |检查import声明| D[依赖]
C --> E[模块信息]
D --> E
E --> F[依赖关系图]
F --> |生成最终代码| G[output]</pre>

<h1 id="代码处理"><a href="#代码处理" class="headerlink" title="代码处理"></a>代码处理</h1><ol>
<li>解析（parse）。将源代码变成AST。</li>
<li>转换（transform）。操作AST，这也是我们可以操作的部分，去改变代码。</li>
<li>生成（generate）。将更改后的AST，再变回代码。  <blockquote>
<p>参考：<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-stages-of-babel">Babel用户手册</a></p>
</blockquote>
</li>
</ol>
<p>下面我将介绍一些这个过程中需要用到的工具。</p>
<h2 id="解析器-babylon"><a href="#解析器-babylon" class="headerlink" title="解析器 babylon"></a>解析器 babylon</h2><p>用来将源代码转换为 AST。<br>（不了解 AST 的，可以先看看<a href="https://astexplorer.net/">在线AST转换器</a>。）</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save babylon</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</span><br><span class="line"></span><br><span class="line">babylon.parse(code, [options])</span><br></pre></td></tr></table></figure>

<h2 id="转换器-babel-traverse"><a href="#转换器-babel-traverse" class="headerlink" title="转换器 babel-traverse"></a>转换器 babel-traverse</h2><p>用来操作 AST</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save babel-traverse</span><br></pre></td></tr></table></figure>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>该模块仅暴露出一个 traverse 方法。traverse 方法是一个遍历方法， path 封装了每一个节点，并且还提供容器 container ，作用域 scope 这样的字段。提供个更多关于节点的相关的信息，让我们更好的操作节点。<br>示例：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"babel-traverse"</span>;</span><br><span class="line"></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.node.type === <span class="string">"Identifier"</span></span><br><span class="line">      &amp;&amp; path.node.name === <span class="string">'text'</span>) &#123;</span><br><span class="line">      path.node.name = <span class="string">'alteredText'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="生成器-babel-generator"><a href="#生成器-babel-generator" class="headerlink" title="生成器 babel-generator"></a>生成器 babel-generator</h2><p>可以根据 AST 生成代码</p>
<h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save babel-generator</span><br></pre></td></tr></table></figure>

<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">"babel-generator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genCode = generate(ast, &#123;&#125;, code);</span><br></pre></td></tr></table></figure>

<h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><h2 id="第一步，提取某文件的依赖"><a href="#第一步，提取某文件的依赖" class="headerlink" title="第一步，提取某文件的依赖"></a>第一步，提取某文件的依赖</h2><p>最开始我们提到，需要构建一个依赖关系图。那么我们先从第一步开始，实现根据某个文件（输入绝对路径）提取依赖。大致可以分成以下几步：</p>
<ol>
<li>读取文件内容</li>
<li>生成 AST</li>
<li>遍历 AST 来理解这个模块依赖哪些模块</li>
<li>为该模块分配唯一标识符</li>
<li>使代码支持所有浏览器</li>
</ol>
<h3 id="读取文件内容"><a href="#读取文件内容" class="headerlink" title="读取文件内容"></a>读取文件内容</h3><p>我们用 node.js 的 <code>fs</code> 模块就可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">'utf-8'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="生成-AST"><a href="#生成-AST" class="headerlink" title="生成 AST"></a>生成 AST</h3><p>用到我们之前提到的 babylon</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ast = babylon.parse(content, &#123;</span><br><span class="line">  sourceType: <span class="string">'module'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="遍历-AST-来试着理解这个模块依赖哪些模块"><a href="#遍历-AST-来试着理解这个模块依赖哪些模块" class="headerlink" title="遍历 AST 来试着理解这个模块依赖哪些模块"></a>遍历 AST 来试着理解这个模块依赖哪些模块</h3><p>这里我们需要操作 AST，所以用到 babel-traverse</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dependencies = [];</span><br><span class="line"><span class="comment">// 要做到这一点,我们检查`ast`中的每个 `import` 声明.</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line"><span class="comment">// `Ecmascript`模块相当简单,因为它们是静态的. 这意味着你不能`import`一个变量,</span></span><br><span class="line"><span class="comment">// 或者有条件地`import`另一个模块. </span></span><br><span class="line"><span class="comment">// 每次我们看到`import`声明时,我们都可以将其数值视为`依赖性`.</span></span><br><span class="line">  ImportDeclaration: <span class="function">(<span class="params">&#123;node&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    dependencies.push(node.source.value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="为模块分配唯一标识符"><a href="#为模块分配唯一标识符" class="headerlink" title="为模块分配唯一标识符"></a>为模块分配唯一标识符</h3><p>我们简单地用 id 表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 递增简单计数器</span><br><span class="line">const id &#x3D; ID++;</span><br></pre></td></tr></table></figure>

<h3 id="使代码支持所有浏览器"><a href="#使代码支持所有浏览器" class="headerlink" title="使代码支持所有浏览器"></a>使代码支持所有浏览器</h3><p>使用 <a href="https://www.babeljs.cn/docs/">babel</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;transformFromAst&#125; = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该`presets`选项是一组规则,告诉`babel`如何传输我们的代码. </span></span><br><span class="line"><span class="comment">// 我们用`babel-preset-env``将我们的代码转换为浏览器可以运行的东西. </span></span><br><span class="line"><span class="keyword">const</span> &#123;code&#125; = transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">  presets: [<span class="string">'env'</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么 code 到底长什么样呢</p>
<blockquote>
<ol>
<li>首先，babel 能将 es6 等更新的代码转成浏览器能执行的低版本代码，这个之前一直在强调的</li>
<li>其次，对于模块的转换。Babel 对 ES6 模块转码就是转换成 CommonJS 规范  <blockquote>
<ul>
<li>Babel 对于模块输出的转换，就是把所有输出都赋值到 exports 对象的属性上，并加上 ESModule: true 的标识。表示这个模块是由 ESModule 转换来的 CommonJS 输出</li>
<li>输入就是 require</li>
</ul>
</blockquote>
</li>
</ol>
</blockquote>
<p>例如，对于以下文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'./message.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">'./name.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure>
<p>按照上面的规范，转换后的代码大概是这样大概是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> _message = <span class="built_in">require</span>(<span class="string">"./message.js"</span>);</span><br><span class="line"><span class="keyword">var</span> _message2 = _interopRequireDefault(_message);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(_message2.default);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加上 ESModule: true 的标识</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> _name = <span class="built_in">require</span>(<span class="string">"./name.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把所有输出都赋值到 exports 对象的属性上</span></span><br><span class="line">exports.default = <span class="string">"hello "</span> + _name.name + <span class="string">"!"</span>;</span><br></pre></td></tr></table></figure>


<h3 id="返回模块信息"><a href="#返回模块信息" class="headerlink" title="返回模块信息"></a>返回模块信息</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  id,</span><br><span class="line">  filename,</span><br><span class="line">  dependencies,</span><br><span class="line">  code,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上，我们就处理好了一个模块。包含着以下 4 项信息  </p>
<ul>
<li>模块 id</li>
<li>文件的绝对路径</li>
<li>该模块的依赖。保存着的是依赖们的相对路径</li>
<li>该模块内部代码（浏览器可运行）</li>
</ul>
<h2 id="第二步，生成依赖图"><a href="#第二步，生成依赖图" class="headerlink" title="第二步，生成依赖图"></a>第二步，生成依赖图</h2><p>通过第一步，我们已经能生成某个模块的依赖了。接下来，我们就可以顺藤摸瓜，从入口文件开始，生成入口文件的依赖，再生成入口文件的依赖的依赖，再生成入口文件的依赖的依赖依…（禁止套娃），直到所有模块处理完毕</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry 为入口文件的路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// createAsset 是我们在【第一步，提取某文件的依赖】中实现的函数</span></span><br><span class="line">  <span class="comment">// mainAsset 就是入口模块的信息了</span></span><br><span class="line">  <span class="keyword">const</span> mainAsset = createAsset(entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用一个队列，刚开始只有入口模块</span></span><br><span class="line">  <span class="keyword">const</span> queue = [mainAsset];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mapping 用来将【依赖的相对路径】映射到【该依赖的模块 id】</span></span><br><span class="line">    asset.mapping = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个模块所在的目录. </span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个依赖。</span></span><br><span class="line">    asset.dependencies.forEach(<span class="function"><span class="params">relativePath</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 得到依赖的绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 得到 child 的模块信息</span></span><br><span class="line">      <span class="keyword">const</span> child = createAsset(absolutePath);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将【依赖的相对路径】映射到【该依赖的模块 id】</span></span><br><span class="line">      <span class="comment">// 因为如果不做映射。最终打包到一个文件后，编码时的相对路径就不管用了。我们就没法知道像 require('./child') 这种代码到底应该加载哪一个模块</span></span><br><span class="line">      asset.mapping[relativePath] = child.id;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这个子模块也放进队列里面</span></span><br><span class="line">      queue.push(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这一步,队列 就是一个包含目标应用中 每个模块 的数组</span></span><br><span class="line"><span class="comment">// 实际上这个就是我们最终的依赖关系图了</span></span><br><span class="line">  <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以下文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./example/entry.js</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'./message.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./example/message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">'./name.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./example/name.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'world'</span>;</span><br></pre></td></tr></table></figure>
<p>我们处理后的依赖关系图应该是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    filename: <span class="string">'./example/entry.js'</span>,</span><br><span class="line">    dependencies: [<span class="string">'./message.js'</span>],</span><br><span class="line">    code: ,<span class="comment">// 略</span></span><br><span class="line">    mapping: &#123;</span><br><span class="line">        <span class="string">'./message.js'</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    filename: <span class="string">'./example/message.js'</span>,</span><br><span class="line">    dependencies: [<span class="string">'./name.js'</span>],</span><br><span class="line">    code: ,<span class="comment">// 略</span></span><br><span class="line">    mapping: &#123;</span><br><span class="line">        <span class="string">'./name.js'</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    filename: <span class="string">'./example/name.js'</span>,</span><br><span class="line">    dependencies: [],</span><br><span class="line">    code: ,<span class="comment">// 略</span></span><br><span class="line">    mapping: &#123;&#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h3 id="第三步，根据依赖图生成代码"><a href="#第三步，根据依赖图生成代码" class="headerlink" title="第三步，根据依赖图生成代码"></a>第三步，根据依赖图生成代码</h3><p>目前，我们已经有了依赖图</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">graph: Module[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Module &#123;</span><br><span class="line">  id: <span class="built_in">number</span> <span class="comment">// 模块id；在【提取某文件的依赖】这一步中我们使用的是一个递增的 id</span></span><br><span class="line">  filename: <span class="built_in">string</span> </span><br><span class="line">  dependencies: Module[]</span><br><span class="line">  code: <span class="built_in">string</span> <span class="comment">// 该模块的代码（经过转换的，能在浏览器中运行） </span></span><br><span class="line">  mapping: Record&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt; <span class="comment">// 将依赖的相对路径转换成id。是我们在【生成依赖图】这一步所做的工作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">既然已经到了这一步了，就说明我们得处理一下 `</span>code<span class="string">` 了。在【使代码支持所有浏览器】这一步中，我们已经知道了，`</span>code<span class="string">` 是符合 CommonJS 规范的。但CommonJS 中有以下几个东西，是浏览器中没有的：  </span></span><br><span class="line"><span class="string">- require </span></span><br><span class="line"><span class="string">- module </span></span><br><span class="line"><span class="string">- exports  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">那么接下来就是我们自己实现这3个东西！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">首先把咱目前的模块信息整合一下：</span></span><br><span class="line"><span class="string">- mapping 是肯定要的。因为我们模块的被转换后会通过相对路径来调用 require() ，而我们需要知道对应去加载哪个模块  </span></span><br><span class="line"><span class="string">- code 需要稍微改一下。每个模块的作用域应该是独立的。所以我们改成这样：</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">module</span>, exports</span>) </span>&#123; </span><br><span class="line">    &#123;code&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最终把所有这样的模块放在 modules 中，大概是这样：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  &#123;0: [</span></span><br><span class="line"><span class="comment">    function (require, module, exports) &#123; </span></span><br><span class="line"><span class="comment">      &#123;code&#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    mapping: &#123;</span></span><br><span class="line"><span class="comment">      './message.js': 1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  ]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">modules: Record&lt;<span class="built_in">number</span>, [<span class="function">(<span class="params"><span class="built_in">require</span>, <span class="built_in">module</span>, exports</span>) =&gt;</span> <span class="built_in">any</span>, Record&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;]&gt;</span><br></pre></td></tr></table></figure>

<p>接下来我们写主程序，我们主程序要做的工作有</p>
<ol>
<li>实现 <code>require</code>, <code>module</code>, <code>exports</code></li>
<li>默认调用入口文件</li>
<li>自执行</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">id</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 从 modules 拿到 【执行函数】和【mapping】</span></span><br><span class="line">    <span class="keyword">const</span> [fn, mapping] = modules[id];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己实现的 require，可以根据相对路径加载依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">localRequire</span>(<span class="params">name</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">require</span>(mapping[name]); </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// // 自己实现的 module 和 exports</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span> : &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">    fn(localRequire, <span class="built_in">module</span>, <span class="built_in">module</span>.exports); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用入口文件</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">&#125;)(modules)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>打包工具</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现一个深拷贝</title>
    <url>/2020/05/01/deepcopy/</url>
    <content><![CDATA[<p>这部分我是看了 <a href="https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L11087">lodash</a> 的相关源码，它真的实现得非常完整！<br>总结成一句话，就是需要考虑很多数据类型，然后针对这些数据类型拷贝就行了😏</p>
<a id="more"></a>


<p>对于引用类型来说，我们基本可以按照以下思路走：  </p>
<ol>
<li>初始化。即调用相应的构造函数</li>
<li>递归地赋值</li>
<li>有循环引用的话需要处理一下</li>
</ol>
<h1 id="拷贝基本类型"><a href="#拷贝基本类型" class="headerlink" title="拷贝基本类型"></a>拷贝基本类型</h1><p>基本类型直接赋值就可以。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是不是对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> value</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>接下来是怎么拷贝引用类型。我会按照以下顺序来介绍：</p>
<ol>
<li>数组</li>
<li>函数</li>
<li>对象</li>
<li>特殊类型。Boolean、Date、Map、Number 等等</li>
</ol>
<p>另外，lodash 还实现了 Buffer（node.js）等拷贝，但我实际用得不多，就不展开了，有兴趣的可以去看看源码。</p>
<h1 id="拷贝数组"><a href="#拷贝数组" class="headerlink" title="拷贝数组"></a>拷贝数组</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>先初始化一个长度为原数组长度的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待续</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCloneArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> array.constructor(length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 RegExp.prototype.exec() 会返回一个数组或 null，这个数组里有两个特殊的属性：input、index</span></span><br><span class="line">    <span class="comment">// 类似 ["foo", index: 6, input: "table football, foosball", groups: undefined]</span></span><br><span class="line">    <span class="comment">// 所以需要进行特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> (length &amp;&amp; <span class="keyword">typeof</span> array[<span class="number">0</span>] === <span class="string">'string'</span> &amp;&amp; hasOwnProperty.call(array, <span class="string">'index'</span>)) &#123;</span><br><span class="line">        result.index = array.index</span><br><span class="line">        result.input = array.input</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> value) &#123;</span><br><span class="line">        result[k] = deepClone(value[k])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拷贝函数"><a href="#拷贝函数" class="headerlink" title="拷贝函数"></a>拷贝函数</h1><p>函数的拷贝的话，我们还是返回之前的引用。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">        <span class="comment">// 函数</span></span><br><span class="line">        <span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> value) &#123;</span><br><span class="line">        result[k] = deepClone(value[k])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拷贝对象"><a href="#拷贝对象" class="headerlink" title="拷贝对象"></a>拷贝对象</h1><p>初始化一个对象，然后赋值。<br>要注意的是这个拷贝后的对象和原对象的原型链是一样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">  <span class="keyword">const</span> tag = getTag(value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">    result = initCloneArray(value)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">    <span class="comment">// 函数</span></span><br><span class="line">    <span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象或 arguments</span></span><br><span class="line">    <span class="keyword">if</span> (tag == <span class="string">'[object Object]'</span> || tag == <span class="string">'[object Arguments]'</span>) &#123;</span><br><span class="line">      result = initCloneObject(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对象或数组赋值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> value) &#123;</span><br><span class="line">    result[k] = deepClone(value[k])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能更细致地判断是什么类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTag</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value === <span class="literal">undefined</span> ? <span class="string">'[object Undefined]'</span> : <span class="string">'[object Null]'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> toString.call(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectProto = <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = value &amp;&amp; value.constructor</span><br><span class="line">    <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype) || objectProto</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> value === proto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCloneObject</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> object.constructor === <span class="string">'function'</span> &amp;&amp; !isPrototype(object))</span><br><span class="line">      ? <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(object))</span><br><span class="line">      : &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拷贝特殊类型"><a href="#拷贝特殊类型" class="headerlink" title="拷贝特殊类型"></a>拷贝特殊类型</h1><p>包括 <code>Boolean</code>, <code>Date</code>, <code>Error</code>, <code>Map</code>, <code>Number</code>, <code>RegExp</code>, <code>Set</code>,  <code>String</code></p>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
