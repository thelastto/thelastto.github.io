<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>apply/call/bind 一网打尽</title>
    <url>/2020/04/28/apply-call-bind/</url>
    <content><![CDATA[<p>首先，这三个方法是用来改变 this 指向的，接下来我们看一下它们的异同。</p>
<a id="more"></a>

<h1 id="1-apply"><a href="#1-apply" class="headerlink" title="1. apply"></a>1. apply</h1><ul>
<li>调用一个对象的一个方法，用另一个对象替换当前对象。例如：<code>B.apply(A, arguments)</code>; 即 A 对象应用 B 对象的方法。</li>
<li>要注意的是第一个参数，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，而其他原始值则会被相应的包装对象（wrapper object）所替代。</li>
</ul>
<h2 id="1-1-如何实现一个apply"><a href="#1-1-如何实现一个apply" class="headerlink" title="1.1 如何实现一个apply"></a>1.1 如何实现一个apply</h2><p>回顾一下 apply 的效果，我们可以大致按以下思路走</p>
<ol>
<li>实现第一个参数的功能，改变 this 指向</li>
<li>实现第二个参数的功能。第二个参数是作为调用函数的参数</li>
<li>返回值：使用调用者提供的 this 值和参数调用该函数的返回值。若该方法没有返回值，则返回 undefined。</li>
</ol>
<p>接下来，我们按以上思路来实现一下。</p>
<h3 id="1-1-1-第一步，绑定-this"><a href="#1-1-1-第一步，绑定-this" class="headerlink" title="1.1.1 第一步，绑定 this"></a>1.1.1 第一步，绑定 this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">f.apply(o);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与下面代码的功能类似（假设对象o中预先不存在名为m的属性）。</span></span><br><span class="line">o.m=f; <span class="comment">//将f存储为o的临时方法</span></span><br><span class="line">o.m(); <span class="comment">//调用它，不传入参数</span></span><br><span class="line"><span class="keyword">delete</span> o.m;<span class="comment">//将临时方法删除</span></span><br></pre></td></tr></table></figure>
<p>(以上代码摘录自犀牛书)<br>依样画葫芦，我们可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line">    context.__fn()</span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-第二步，给函数传递参数"><a href="#1-1-2-第二步，给函数传递参数" class="headerlink" title="1.1.2 第二步，给函数传递参数"></a>1.1.2 第二步，给函数传递参数</h3><p>接下来我们想办法实现一下 apply 的第二个参数。其实我最快想到的是 ES6 的方法。用<code>...</code> 直接展开就行了。不过 apply 才 ES3😂，还是再想想老的办法吧。</p>
<p>难点是这个数组的长度是不确定的，也就是说我们没办法很准确地给函数一个个传参。我们所能做的处理也就是把<code>arguments</code>转成字符串形式<code>&#39;arguments[1], arguments[2], ...&#39;</code>。那么如何让字符串能运行起来呢？？答案就是 <code>eval</code>！</p>
<p>稍稍总结一下, 目前想到的 2 种方法</p>
<blockquote>
<ol>
<li>es6。<code>context.__fn(...arguments)</code></li>
<li>把 arguments 转换成string，放到 eval 里面运行 <code>eval(&#39;context.__fn(&#39;+ &#39;arguments[1], arguments[2]&#39; +&#39;)&#39;)</code></li>
</ol>
</blockquote>
<p>以下是第二种思路的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, others</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// args: 'others[0], others[1], others[2], ...'</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = others.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'others['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">eval</span>(<span class="string">'context.__fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-第三步，返回值"><a href="#1-1-3-第三步，返回值" class="headerlink" title="1.1.3 第三步，返回值"></a>1.1.3 第三步，返回值</h3><p>返回函数调用后的结果就行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, others</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// args: 'others[0], others[1], others[2], ...'</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = others.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'others['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'context.__fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-4-更进一步，严格模式下的-this"><a href="#1-1-4-更进一步，严格模式下的-this" class="headerlink" title="1.1.4 更进一步，严格模式下的 this"></a>1.1.4 更进一步，严格模式下的 this</h3><p>我们之前有提到：第一个参数，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动替换为指向全局对象，而其他原始值则会被相应的包装对象（wrapper object）所替代</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, others</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> argsArray === <span class="string">'undefined'</span> || argsArray === <span class="literal">null</span>) &#123;</span><br><span class="line">        context = <span class="built_in">window</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// context 是一个 object</span></span><br><span class="line">    context = <span class="keyword">new</span> <span class="built_in">Object</span>(context)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = others.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'others['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'context.__fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-5-再进一步，确保-fn-不存在"><a href="#1-1-5-再进一步，确保-fn-不存在" class="headerlink" title="1.1.5 再进一步，确保 __fn 不存在"></a>1.1.5 再进一步，确保 __fn 不存在</h3><p>我们之前的代码都是建立在 <code>__fn</code> 不存在的情况下，那么万一存在呢？因此我们接下来就要找一个 <code>context</code> 中没有存在过的属性。<br>🤔我们很快可以想到 ES6 的 symbol。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 像这样</span></span><br><span class="line"><span class="keyword">var</span> __fn = <span class="keyword">new</span> <span class="built_in">Symbol</span>()</span><br><span class="line">context[__fn] = <span class="keyword">this</span></span><br></pre></td></tr></table></figure>
<p>🤔如果不用 ES6，那么另一种方法，是根据 <a href="https://juejin.im/post/5bf6c79bf265da6142738b29#heading-4">这篇文章</a>中提到的，自己用 Math.random() 模拟实现独一无二的 key。面试时可以直接用生成时间戳即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 UUID 通用唯一识别码</span></span><br><span class="line"><span class="comment">// 大概生成 这样一串 '18efca2d-6e25-42bf-a636-30b8f9f2de09'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateUUID</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, random;</span><br><span class="line">    <span class="keyword">var</span> uuid = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        random = <span class="built_in">Math</span>.random() * <span class="number">16</span> | <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i === <span class="number">8</span> || i === <span class="number">12</span> || i === <span class="number">16</span> || i === <span class="number">20</span>) &#123;</span><br><span class="line">            uuid += <span class="string">'-'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uuid += (i === <span class="number">12</span> ? <span class="number">4</span> : (i === <span class="number">16</span> ? (random &amp; <span class="number">3</span> | <span class="number">8</span>) : random))</span><br><span class="line">            .toString(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uuid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单实现</span></span><br><span class="line"><span class="comment">// '__' + new Date().getTime();</span></span><br></pre></td></tr></table></figure>
<p>如果这个key万一这对象中还是有，为了保险起见，可以做一次缓存操作(就是先把之前的值保存起来)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 像这样</span></span><br><span class="line"><span class="keyword">var</span> originalvalue = context.__fn</span><br><span class="line"><span class="keyword">var</span> hasOriginalValue = context.hasOwnProperty(<span class="string">'__fn'</span>)</span><br><span class="line">context.__fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(hasOriginalValue)&#123;</span><br><span class="line">    context.__fn = originalvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2-call"><a href="#2-call" class="headerlink" title="2. call"></a>2. call</h1><ul>
<li><p>和 apply 的作用是一样的，只是 <code>call()</code> 方法接受的是一个参数列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p>
</li>
<li><p>例如 <code>func.apply(obj, [1,2])</code> 相当于 <code>func.call(obj, 1, 2)</code></p>
</li>
</ul>
<h2 id="2-1-实现一个-call"><a href="#2-1-实现一个-call" class="headerlink" title="2.1 实现一个 call"></a>2.1 实现一个 call</h2><p>思路和 apply 一样。唯一区别就在于参数形式。我们按照 call 的要求来处理参数就可以了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// context 就是需要绑定的对象，相当于上面的 o</span></span><br><span class="line">    <span class="comment">// this 就是调用了 apply 的函数，相当于 f</span></span><br><span class="line">    context.__fn = <span class="keyword">this</span> <span class="comment">// 假设原先没有__fn</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = [];</span><br><span class="line">    <span class="comment">// 我们从 arguments[1] 开始拼就好了</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">        args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'context.__fn('</span> + args.toString() + <span class="string">')'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.__fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-bind"><a href="#3-bind" class="headerlink" title="3. bind"></a>3. bind</h1><p>我们常将 bind 和以上两个方法区分开，是因为 bind 是 ECMAScript 5 中的方法，且除了将函数绑定至一个对象外还多了一些特点。</p>
<ul>
<li><p><strong>bind() 方法创建一个新的函数</strong>，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的初始参数，供调用时使用。</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">func.apply(obj, [<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">func.call(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">var</span> boundFun = func.bind(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">boundFun()</span><br><span class="line"><span class="comment">// 也可以这样</span></span><br><span class="line"><span class="keyword">var</span> boundFun = func.bind(obj, <span class="number">1</span>)</span><br><span class="line">boundFun(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>绑定函数也可以使用 new 运算符构造</strong>，它会表现为目标函数已经被构建完毕了似的。提供的 this 值会被忽略，但前置参数仍会提供给模拟函数。</p>
</li>
</ul>
<h2 id="3-1-实现一个-bind"><a href="#3-1-实现一个-bind" class="headerlink" title="3.1 实现一个 bind"></a>3.1 实现一个 bind</h2><p>我们还是先大致思考一下该怎么做：</p>
<ol>
<li>实现第一个参数的功能，改变 this 指向。这个和 apply/call 是一样的。</li>
<li>返回值：返回一个新的函数。</li>
<li>实现其它参数。其它参数将作为新函数的初始参数，供调用时使用。这个和 call 有些相似。</li>
<li>使用 new 操作符时，应该忽略第一个参数</li>
</ol>
<p>后续的步骤我会用 apply/call 来实现bind。如果不想直接用 apply/call，也可以按照上文先实现一个 apply/call。</p>
<h3 id="3-1-1-第一步，返回一个绑定了-this-的新函数"><a href="#3-1-1-第一步，返回一个绑定了-this-的新函数" class="headerlink" title="3.1.1 第一步，返回一个绑定了 this 的新函数"></a>3.1.1 第一步，返回一个绑定了 this 的新函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-第二步，给新函数设定初始参数"><a href="#3-1-2-第二步，给新函数设定初始参数" class="headerlink" title="3.1.2 第二步，给新函数设定初始参数"></a>3.1.2 第二步，给新函数设定初始参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 bind 函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> initialArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个绑定好 this 的新函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个是调用新函数时传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> boundArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 最终的参数应该是初始参数+新函数的参数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-第三步，作为构造函数调用时，忽略要绑定的-this"><a href="#3-1-3-第三步，作为构造函数调用时，忽略要绑定的-this" class="headerlink" title="3.1.3 第三步，作为构造函数调用时，忽略要绑定的 this"></a>3.1.3 第三步，作为构造函数调用时，忽略要绑定的 this</h3><p>这里的难点是怎么知道是由 new 调用的。<br>先说一下答案吧</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假如有以下函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 <code>var gioia = new Person()</code> 来说<br>使用 new 时，this 会指向 gioia，并且 gioia 是 Person 的实例。<br>因此，如果 <code>this instance Person</code>，就说明是 new 调用的</p>
</blockquote>
<p>new 这一部分这里先不展开讲，有兴趣的可以看一下 <a href="https://github.com/mqyqingfeng/Blog/issues/13">JavaScript深入之new的模拟实现</a><br>接下来我们可以写代码了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 bind 函数从第二个参数到最后一个参数</span></span><br><span class="line">    <span class="keyword">var</span> initialArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回一个绑定好 this 的新函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Bound</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个是调用新函数时传入的参数</span></span><br><span class="line">        <span class="keyword">var</span> boundArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// 最终的参数应该是初始参数+新函数的参数</span></span><br><span class="line">        <span class="keyword">return</span> self.apply(<span class="keyword">this</span> instance Bound ? <span class="keyword">this</span> : context, args.concat(bindArgs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Bound.prototype = <span class="keyword">this</span>.prototype</span><br><span class="line">    <span class="keyword">return</span> Bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-参考文章"><a href="#4-参考文章" class="headerlink" title="4. 参考文章"></a>4. 参考文章</h1><ul>
<li><a href="https://juejin.im/post/5bf6c79bf265da6142738b29">面试官问：能否模拟实现JS的call和apply方法</a></li>
<li><a href="https://juejin.im/post/5907eb99570c3500582ca23c">JavaScript深入之call和apply的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/12">JavaScript深入之bind的模拟实现</a></li>
</ul>
]]></content>
      <tags>
        <tag>this</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>写一个简易的打包工具</title>
    <url>/2020/04/30/miniwebpack/</url>
    <content><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>不知道有没有人和我一样，不管看了几遍文档，还是不会自己写 webpack，只能在别人写的配置上修修补补，更别提什么优化了。<br>于是我痛定思痛，决定从源头上解决这个问题！为了更好地应用 webpack，我们应该了解它背后的工作原理。<br>因此，我阅读了 <a href="https://github.com/ronami/minipack/blob/master/src/minipack.js">miniwebpack</a> 这个仓库。这个仓库实现了一个最简单的打包工具。接下来我会按照我的理解来解释一下怎么实现一个简单的打包工具</p>
<a id="more"></a>

<h1 id="2-主要思路"><a href="#2-主要思路" class="headerlink" title="2. 主要思路"></a>2. 主要思路</h1><ol>
<li>代码处理。我们平常写代码的时候，用的可能是ES6、ES7等高版本的语法，我们需要将它们转换成浏览器能运行的语法</li>
<li>打包。需要根据一个 entry 来输出一个 output，我们通过维护一个依赖关系图来解决这个问题</li>
</ol>
<pre class="mermaid">graph LR
A[entry] --> |解析代码| B[AST]
B --> |生成| C[浏览器可用代码]
B --> |检查import声明| D[依赖]
C --> E[模块信息]
D --> E
E --> F[依赖关系图]
F --> |生成最终代码| G[output]</pre>

<h1 id="3-代码处理"><a href="#3-代码处理" class="headerlink" title="3. 代码处理"></a>3. 代码处理</h1><ol>
<li>解析（parse）。将源代码变成AST。</li>
<li>转换（transform）。操作AST，这也是我们可以操作的部分，去改变代码。</li>
<li>生成（generate）。将更改后的AST，再变回代码。  <blockquote>
<p>参考：<a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-stages-of-babel">Babel用户手册</a></p>
</blockquote>
</li>
</ol>
<p>下面我将介绍一些这个过程中需要用到的工具。</p>
<h2 id="3-1-解析器-babylon"><a href="#3-1-解析器-babylon" class="headerlink" title="3.1 解析器 babylon"></a>3.1 解析器 babylon</h2><p>用来将源代码转换为 AST。<br>（不了解 AST 的，可以先看看<a href="https://astexplorer.net/">在线AST转换器</a>。）</p>
<h3 id="3-1-1-安装"><a href="#3-1-1-安装" class="headerlink" title="3.1.1 安装"></a>3.1.1 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save babylon</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2  使用"></a>3.1.2  使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> babylon <span class="keyword">from</span> <span class="string">"babylon"</span>;</span><br><span class="line"></span><br><span class="line">babylon.parse(code, [options])</span><br></pre></td></tr></table></figure>

<h2 id="3-2-转换器-babel-traverse"><a href="#3-2-转换器-babel-traverse" class="headerlink" title="3.2 转换器 babel-traverse"></a>3.2 转换器 babel-traverse</h2><p>用来操作 AST</p>
<h3 id="3-2-1-安装"><a href="#3-2-1-安装" class="headerlink" title="3.2.1 安装"></a>3.2.1 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save babel-traverse</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-使用"><a href="#3-2-2-使用" class="headerlink" title="3.2.2 使用"></a>3.2.2 使用</h3><p>该模块仅暴露出一个 traverse 方法。traverse 方法是一个遍历方法， path 封装了每一个节点，并且还提供容器 container ，作用域 scope 这样的字段。提供个更多关于节点的相关的信息，让我们更好的操作节点。<br>示例：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">import</span> traverse <span class="keyword">from</span> <span class="string">"babel-traverse"</span>;</span><br><span class="line"></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line">  enter(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.node.type === <span class="string">"Identifier"</span></span><br><span class="line">      &amp;&amp; path.node.name === <span class="string">'text'</span>) &#123;</span><br><span class="line">      path.node.name = <span class="string">'alteredText'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-3-生成器-babel-generator"><a href="#3-3-生成器-babel-generator" class="headerlink" title="3.3 生成器 babel-generator"></a>3.3 生成器 babel-generator</h2><p>可以根据 AST 生成代码</p>
<h3 id="3-3-1-安装"><a href="#3-3-1-安装" class="headerlink" title="3.3.1 安装"></a>3.3.1 安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install --save babel-generator</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-使用"><a href="#3-3-2-使用" class="headerlink" title="3.3.2 使用"></a>3.3.2 使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> generate <span class="keyword">from</span> <span class="string">"babel-generator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> genCode = generate(ast, &#123;&#125;, code);</span><br></pre></td></tr></table></figure>

<h1 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h1><h2 id="4-1-第一步，提取某文件的依赖"><a href="#4-1-第一步，提取某文件的依赖" class="headerlink" title="4.1 第一步，提取某文件的依赖"></a>4.1 第一步，提取某文件的依赖</h2><p>最开始我们提到，需要构建一个依赖关系图。那么我们先从第一步开始，实现根据某个文件（输入绝对路径）提取依赖。大致可以分成以下几步：</p>
<ol>
<li>读取文件内容</li>
<li>生成 AST</li>
<li>遍历 AST 来理解这个模块依赖哪些模块</li>
<li>为该模块分配唯一标识符</li>
<li>使代码支持所有浏览器</li>
</ol>
<h3 id="4-1-1-读取文件内容"><a href="#4-1-1-读取文件内容" class="headerlink" title="4.1.1 读取文件内容"></a>4.1.1 读取文件内容</h3><p>我们用 node.js 的 <code>fs</code> 模块就可以</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">'utf-8'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-生成-AST"><a href="#4-1-2-生成-AST" class="headerlink" title="4.1.2 生成 AST"></a>4.1.2 生成 AST</h3><p>用到我们之前提到的 babylon</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ast = babylon.parse(content, &#123;</span><br><span class="line">  sourceType: <span class="string">'module'</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-遍历-AST-来试着理解这个模块依赖哪些模块"><a href="#4-1-3-遍历-AST-来试着理解这个模块依赖哪些模块" class="headerlink" title="4.1.3 遍历 AST 来试着理解这个模块依赖哪些模块"></a>4.1.3 遍历 AST 来试着理解这个模块依赖哪些模块</h3><p>这里我们需要操作 AST，所以用到 babel-traverse</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dependencies = [];</span><br><span class="line"><span class="comment">// 要做到这一点,我们检查`ast`中的每个 `import` 声明.</span></span><br><span class="line">traverse(ast, &#123;</span><br><span class="line"><span class="comment">// `Ecmascript`模块相当简单,因为它们是静态的. 这意味着你不能`import`一个变量,</span></span><br><span class="line"><span class="comment">// 或者有条件地`import`另一个模块. </span></span><br><span class="line"><span class="comment">// 每次我们看到`import`声明时,我们都可以将其数值视为`依赖性`.</span></span><br><span class="line">  ImportDeclaration: <span class="function">(<span class="params">&#123;node&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    dependencies.push(node.source.value);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-1-4-为模块分配唯一标识符"><a href="#4-1-4-为模块分配唯一标识符" class="headerlink" title="4.1.4 为模块分配唯一标识符"></a>4.1.4 为模块分配唯一标识符</h3><p>我们简单地用 id 表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 递增简单计数器</span><br><span class="line">const id &#x3D; ID++;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-5-使代码支持所有浏览器"><a href="#4-1-5-使代码支持所有浏览器" class="headerlink" title="4.1.5 使代码支持所有浏览器"></a>4.1.5 使代码支持所有浏览器</h3><p>使用 <a href="https://www.babeljs.cn/docs/">babel</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;transformFromAst&#125; = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该`presets`选项是一组规则,告诉`babel`如何传输我们的代码. </span></span><br><span class="line"><span class="comment">// 我们用`babel-preset-env``将我们的代码转换为浏览器可以运行的东西. </span></span><br><span class="line"><span class="keyword">const</span> &#123;code&#125; = transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">  presets: [<span class="string">'env'</span>],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么 code 到底长什么样呢</p>
<blockquote>
<ol>
<li>首先，babel 能将 es6 等更新的代码转成浏览器能执行的低版本代码，这个之前一直在强调的</li>
<li>其次，对于模块的转换。Babel 对 ES6 模块转码就是转换成 CommonJS 规范<br>Babel 对于模块输出的转换，就是把所有输出都赋值到 exports 对象的属性上，并加上 ESModule: true 的标识。表示这个模块是由 ESModule 转换来的 CommonJS 输出<br>输入就是 require</li>
</ol>
</blockquote>
<p>例如，对于以下文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'./message.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">'./name.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure>
<p>按照上面的规范，转换后的代码大概是这样大概是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> _message = <span class="built_in">require</span>(<span class="string">"./message.js"</span>);</span><br><span class="line"><span class="keyword">var</span> _message2 = _interopRequireDefault(_message);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(_message2.default);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加上 ESModule: true 的标识</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">"__esModule"</span>, &#123;</span><br><span class="line">  value: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> _name = <span class="built_in">require</span>(<span class="string">"./name.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把所有输出都赋值到 exports 对象的属性上</span></span><br><span class="line">exports.default = <span class="string">"hello "</span> + _name.name + <span class="string">"!"</span>;</span><br></pre></td></tr></table></figure>


<h3 id="4-1-6-返回模块信息"><a href="#4-1-6-返回模块信息" class="headerlink" title="4.1.6 返回模块信息"></a>4.1.6 返回模块信息</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  id,</span><br><span class="line">  filename,</span><br><span class="line">  dependencies,</span><br><span class="line">  code,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上，我们就处理好了一个模块。包含着以下 4 项信息  </p>
<ul>
<li>模块 id</li>
<li>文件的绝对路径</li>
<li>该模块的依赖。保存着的是依赖们的相对路径</li>
<li>该模块内部代码（浏览器可运行）</li>
</ul>
<h2 id="4-2-第二步，生成依赖图"><a href="#4-2-第二步，生成依赖图" class="headerlink" title="4.2 第二步，生成依赖图"></a>4.2 第二步，生成依赖图</h2><p>通过第一步，我们已经能生成某个模块的依赖了。接下来，我们就可以顺藤摸瓜，从入口文件开始，生成入口文件的依赖，再生成入口文件的依赖的依赖，再生成入口文件的依赖的依赖依…（禁止套娃），直到所有模块处理完毕</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry 为入口文件的路径</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createGraph</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// createAsset 是我们在【第一步，提取某文件的依赖】中实现的函数</span></span><br><span class="line">  <span class="comment">// mainAsset 就是入口模块的信息了</span></span><br><span class="line">  <span class="keyword">const</span> mainAsset = createAsset(entry);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用一个队列，刚开始只有入口模块</span></span><br><span class="line">  <span class="keyword">const</span> queue = [mainAsset];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mapping 用来将【依赖的相对路径】映射到【该依赖的模块 id】</span></span><br><span class="line">    asset.mapping = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个模块所在的目录. </span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filename);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历每一个依赖。</span></span><br><span class="line">    asset.dependencies.forEach(<span class="function"><span class="params">relativePath</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 得到依赖的绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 得到 child 的模块信息</span></span><br><span class="line">      <span class="keyword">const</span> child = createAsset(absolutePath);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将【依赖的相对路径】映射到【该依赖的模块 id】</span></span><br><span class="line">      <span class="comment">// 因为如果不做映射。最终打包到一个文件后，编码时的相对路径就不管用了。我们就没法知道像 require('./child') 这种代码到底应该加载哪一个模块</span></span><br><span class="line">      asset.mapping[relativePath] = child.id;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 把这个子模块也放进队列里面</span></span><br><span class="line">      queue.push(child);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这一步,队列 就是一个包含目标应用中 每个模块 的数组</span></span><br><span class="line"><span class="comment">// 实际上这个就是我们最终的依赖关系图了</span></span><br><span class="line">  <span class="keyword">return</span> queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于以下文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./example/entry.js</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'./message.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./example/message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name&#125; <span class="keyword">from</span> <span class="string">'./name.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">`hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./example/name.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'world'</span>;</span><br></pre></td></tr></table></figure>
<p>我们处理后的依赖关系图应该是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    id: <span class="number">0</span>,</span><br><span class="line">    filename: <span class="string">'./example/entry.js'</span>,</span><br><span class="line">    dependencies: [<span class="string">'./message.js'</span>],</span><br><span class="line">    code: ,<span class="comment">// 略</span></span><br><span class="line">    mapping: &#123;</span><br><span class="line">        <span class="string">'./message.js'</span>: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    filename: <span class="string">'./example/message.js'</span>,</span><br><span class="line">    dependencies: [<span class="string">'./name.js'</span>],</span><br><span class="line">    code: ,<span class="comment">// 略</span></span><br><span class="line">    mapping: &#123;</span><br><span class="line">        <span class="string">'./name.js'</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">    filename: <span class="string">'./example/name.js'</span>,</span><br><span class="line">    dependencies: [],</span><br><span class="line">    code: ,<span class="comment">// 略</span></span><br><span class="line">    mapping: &#123;&#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="4-3-第三步，根据依赖图生成代码"><a href="#4-3-第三步，根据依赖图生成代码" class="headerlink" title="4.3 第三步，根据依赖图生成代码"></a>4.3 第三步，根据依赖图生成代码</h2><p>目前，我们已经有了依赖图</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">graph: Module[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Module &#123;</span><br><span class="line">  id: <span class="built_in">number</span> <span class="comment">// 模块id；在【提取某文件的依赖】这一步中我们使用的是一个递增的 id</span></span><br><span class="line">  filename: <span class="built_in">string</span> </span><br><span class="line">  dependencies: Module[]</span><br><span class="line">  code: <span class="built_in">string</span> <span class="comment">// 该模块的代码（经过转换的，能在浏览器中运行） </span></span><br><span class="line">  mapping: Record&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt; <span class="comment">// 将依赖的相对路径转换成id。是我们在【生成依赖图】这一步所做的工作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">既然已经到了这一步了，就说明我们得处理一下 `</span>code<span class="string">` 了。在【使代码支持所有浏览器】这一步中，我们已经知道了，`</span>code<span class="string">` 是符合 CommonJS 规范的。但CommonJS 中有以下几个东西，是浏览器中没有的：  </span></span><br><span class="line"><span class="string">- require </span></span><br><span class="line"><span class="string">- module </span></span><br><span class="line"><span class="string">- exports  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">那么接下来就是我们自己实现这3个东西！</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">首先把咱目前的模块信息整合一下：</span></span><br><span class="line"><span class="string">- mapping 是肯定要的。因为我们模块的被转换后会通过相对路径来调用 require() ，而我们需要知道对应去加载哪个模块  </span></span><br><span class="line"><span class="string">- code 需要稍微改一下。每个模块的作用域应该是独立的。所以我们改成这样：</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>javascript</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">module</span>, exports</span>) </span>&#123; </span><br><span class="line">    &#123;code&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>最终把所有这样的模块放在 modules 中，大概是这样：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  &#123;0: [</span></span><br><span class="line"><span class="comment">    function (require, module, exports) &#123; </span></span><br><span class="line"><span class="comment">      &#123;code&#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    mapping: &#123;</span></span><br><span class="line"><span class="comment">      './message.js': 1</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">  ]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">modules: Record&lt;<span class="built_in">number</span>, [<span class="function">(<span class="params"><span class="built_in">require</span>, <span class="built_in">module</span>, exports</span>) =&gt;</span> <span class="built_in">any</span>, Record&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;]&gt;</span><br></pre></td></tr></table></figure>

<p>接下来我们写主程序，我们主程序要做的工作有</p>
<ol>
<li>实现 <code>require</code>, <code>module</code>, <code>exports</code></li>
<li>默认调用入口文件</li>
<li>自执行</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">id</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 从 modules 拿到 【执行函数】和【mapping】</span></span><br><span class="line">    <span class="keyword">const</span> [fn, mapping] = modules[id];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自己实现的 require，可以根据相对路径加载依赖</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">localRequire</span>(<span class="params">name</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">require</span>(mapping[name]); </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// // 自己实现的 module 和 exports</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span> : &#123;&#125; &#125;;</span><br><span class="line"></span><br><span class="line">    fn(localRequire, <span class="built_in">module</span>, <span class="built_in">module</span>.exports); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用入口文件</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">&#125;)(modules)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>webpack</tag>
        <tag>打包工具</tag>
      </tags>
  </entry>
  <entry>
    <title>如何实现一个深拷贝</title>
    <url>/2020/05/01/deepcopy/</url>
    <content><![CDATA[<p>这部分我是看了 <a href="https://github.com/lodash/lodash/blob/4.17.15/lodash.js#L11087">lodash</a> 的相关源码，它真的实现得非常完整！<br>总结成一句话，就是需要考虑很多数据类型，然后针对这些数据类型拷贝就行了😏</p>
<a id="more"></a>


<p>对于引用类型来说，我们基本可以按照以下思路走：  </p>
<ol>
<li>初始化。即调用相应的构造函数</li>
<li>递归地赋值</li>
<li>有循环引用的话需要处理一下</li>
</ol>
<h1 id="1-拷贝基本类型"><a href="#1-拷贝基本类型" class="headerlink" title="1. 拷贝基本类型"></a>1. 拷贝基本类型</h1><p>基本类型直接赋值就可以。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是不是对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> type = <span class="keyword">typeof</span> value</span><br><span class="line">    <span class="keyword">return</span> value != <span class="literal">null</span> &amp;&amp; (type === <span class="string">'object'</span> || type === <span class="string">'function'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>接下来是怎么拷贝引用类型。我会按照以下顺序来介绍：</p>
<ol>
<li>数组</li>
<li>函数</li>
<li>对象</li>
<li>特殊类型。Boolean、Date、Map、Number 等等</li>
</ol>
<p>另外，lodash 还实现了 Buffer（node.js）等拷贝，但我实际用得不多，就不展开了，有兴趣的可以去看看源码。</p>
<h1 id="2-拷贝数组"><a href="#2-拷贝数组" class="headerlink" title="2. 拷贝数组"></a>2. 拷贝数组</h1><h2 id="2-1-初始化"><a href="#2-1-初始化" class="headerlink" title="2.1 初始化"></a>2.1 初始化</h2><p>先初始化一个长度为原数组长度的数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 待续</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCloneArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> array.constructor(length)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 RegExp.prototype.exec() 会返回一个数组或 null，这个数组里有两个特殊的属性：input、index</span></span><br><span class="line">    <span class="comment">// 类似 ["foo", index: 6, input: "table football, foosball", groups: undefined]</span></span><br><span class="line">    <span class="comment">// 所以需要进行特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> (length &amp;&amp; <span class="keyword">typeof</span> array[<span class="number">0</span>] === <span class="string">'string'</span> &amp;&amp; hasOwnProperty.call(array, <span class="string">'index'</span>)) &#123;</span><br><span class="line">        result.index = array.index</span><br><span class="line">        result.input = array.input</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-赋值"><a href="#2-2-赋值" class="headerlink" title="2.2 赋值"></a>2.2 赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; value.length; i++) &#123;</span><br><span class="line">            result[i] = deepClone(value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-拷贝函数"><a href="#3-拷贝函数" class="headerlink" title="3. 拷贝函数"></a>3. 拷贝函数</h1><p>函数的拷贝的话，我们还是返回之前的引用。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">        <span class="comment">// 函数</span></span><br><span class="line">        <span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; value.length; i++) &#123;</span><br><span class="line">            result[i] = deepClone(value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-拷贝对象"><a href="#4-拷贝对象" class="headerlink" title="4. 拷贝对象"></a>4. 拷贝对象</h1><p>初始化一个对象，然后赋值。<br>要注意的是这个拷贝后的对象和原对象的原型链是一样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    <span class="keyword">const</span> tag = getTag(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">        <span class="comment">// 函数</span></span><br><span class="line">        <span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象或 arguments</span></span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="string">'[object Object]'</span> || tag == <span class="string">'[object Arguments]'</span>) &#123;</span><br><span class="line">            result = initCloneObject(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        <span class="comment">// 数组赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; value.length; i++) &#123;</span><br><span class="line">            result[i] = deepClone(value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对象赋值</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(<span class="built_in">Object</span>(value)).forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">            result[k] = deepClone(value[k])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 能更细致地判断是什么类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTag</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value === <span class="literal">undefined</span> ? <span class="string">'[object Undefined]'</span> : <span class="string">'[object Null]'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toString.call(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectProto = <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = value &amp;&amp; value.constructor</span><br><span class="line">    <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype) || objectProto</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> value === proto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCloneObject</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> object.constructor === <span class="string">'function'</span> &amp;&amp; !isPrototype(object))</span><br><span class="line">      ? <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(object))</span><br><span class="line">      : &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-拷贝特殊对象"><a href="#5-拷贝特殊对象" class="headerlink" title="5. 拷贝特殊对象"></a>5. 拷贝特殊对象</h1><p>包括 <code>Boolean</code>, <code>Date</code>, <code>Map</code>, <code>Number</code>, <code>RegExp</code>, <code>Set</code>,  <code>String</code>, <code>Symbol</code></p>
<p>接下来的思路也是一样的，先调用对应的构造函数。然后赋值就行了。稍微麻烦一点的可能是 Regexp 正则对象和 Symbol 对象</p>
<h2 id="5-1-初始化"><a href="#5-1-初始化" class="headerlink" title="5.1 初始化"></a>5.1 初始化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    <span class="keyword">const</span> tag = getTag(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">        <span class="comment">// 函数</span></span><br><span class="line">        <span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 对象或 arguments</span></span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="string">'[object Object]'</span> || tag == <span class="string">'[object Arguments]'</span>) &#123;</span><br><span class="line">            result = initCloneObject(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 特殊对象的初始化</span></span><br><span class="line">            result = initCloneByTag(value, tag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        <span class="comment">// 数组赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; value.length; i++) &#123;</span><br><span class="line">            result[i] = deepClone(value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对象赋值</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(<span class="built_in">Object</span>(value)).forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">            result[k] = deepClone(value[k])</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line"><span class="comment">// 能更细致地判断是什么类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTag</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value === <span class="literal">undefined</span> ? <span class="string">'[object Undefined]'</span> : <span class="string">'[object Null]'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toString.call(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectProto = <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrototype</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = value &amp;&amp; value.constructor</span><br><span class="line">    <span class="keyword">const</span> proto = (<span class="keyword">typeof</span> Ctor === <span class="string">'function'</span> &amp;&amp; Ctor.prototype) || objectProto</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> value === proto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊对象的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initCloneByTag</span>(<span class="params">object, tag, isDeep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Ctor = object.constructor</span><br><span class="line">    <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Date]'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ctor(+object)</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Set]'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Map]'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ctor</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Number]'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object String]'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Ctor(object)</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:</span><br><span class="line">        <span class="keyword">return</span> cloneRegExp(object)</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">case</span> <span class="string">'[object Symbol]'</span>:</span><br><span class="line">        <span class="keyword">return</span> cloneSymbol(object)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span></span><br><span class="line"><span class="comment">// 拷贝一个正则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">regexp</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// RegExp 构造函数有两个参数。pattern（正则表达式的文本。），flags（标志）</span></span><br><span class="line">    <span class="comment">// source 属性返回一个值为当前正则表达式对象的模式文本的字符串，该字符串不会包含正则字面量两边的斜杠以及任何的标志字符。</span></span><br><span class="line">    <span class="comment">// reFlags.exec(regexp) 实际上是 reFlags.exec(regexp.toString())。提取出了标志字符</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">new</span> regexp.constructor(regexp.source, reFlags.exec(regexp))</span><br><span class="line">    result.lastIndex = regexp.lastIndex</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> symbolValueOf = <span class="built_in">Symbol</span>.prototype.valueOf</span><br><span class="line"><span class="comment">// 拷贝一个 Symbol</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneSymbol</span>(<span class="params">symbol</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>(symbolValueOf.call(symbol))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-赋值"><a href="#5-2-赋值" class="headerlink" title="5.2 赋值"></a>5.2 赋值</h2><p>虽然是特殊对象，但也是对象，所以我们的思路还是获取该对象的所有属性，然后赋值就可以了。<br>需要注意的是  </p>
<ol>
<li><code>Object.keys</code> 不能获取 Symbol 属性，可以再加上 <code>Object.getOwnPropertySymbols()</code>来获取所有 Symbol 属性名  </li>
<li>Set 和 Map 的赋值是通过 add 和 set 来的</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    <span class="keyword">const</span> tag = getTag(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">        <span class="comment">// 函数</span></span><br><span class="line">        <span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 对象或 arguments</span></span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="string">'[object Object]'</span> || tag == <span class="string">'[object Arguments]'</span>) &#123;</span><br><span class="line">            result = initCloneObject(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 特殊对象的初始化</span></span><br><span class="line">            result = initCloneByTag(value, tag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (tag === mapTag) &#123;</span><br><span class="line">        value.forEach(<span class="function">(<span class="params">subValue, key</span>) =&gt;</span> &#123;</span><br><span class="line">            result.set(key, deepClone(subValue))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (tag === setTag) &#123;</span><br><span class="line">        value.forEach(<span class="function">(<span class="params">subValue</span>) =&gt;</span> &#123;</span><br><span class="line">            result.add(deepClone(subValue))</span><br><span class="line">        &#125;)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        <span class="comment">// 数组赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; value.length; i++) &#123;</span><br><span class="line">            result[i] = deepClone(value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对象赋值</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(<span class="built_in">Object</span>(value)).forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">            result[k] = deepClone(value[k])</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> propertyIsEnumerable = <span class="built_in">Object</span>.prototype.propertyIsEnumerable</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 过滤掉不可枚举的 Symbol 属性并赋值</span></span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertySymbols(value)</span><br><span class="line">            .filter(<span class="function">(<span class="params">symbol</span>) =&gt;</span> propertyIsEnumerable.call(value, symbol))</span><br><span class="line">            .forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">                result[k] = deepClone(value[k])</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-测试"><a href="#6-测试" class="headerlink" title="6. 测试"></a>6. 测试</h1><div class="tabs" id="[test]"><ul class="nav-tabs"><li class="tab active"><a href="#[test]-1">test</a></li><li class="tab"><a href="#[test]-2">result</a></li></ul><div class="tab-content"><div class="tab-pane active" id="[test]-1"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set()</span><br><span class="line"><span class="keyword">set</span>.add('gioia')</span><br><span class="line"><span class="keyword">set</span>.add('me')</span><br><span class="line"></span><br><span class="line">const map = new Map()</span><br><span class="line">map.<span class="keyword">set</span>(0, 'zero')</span><br><span class="line">map.<span class="keyword">set</span>(1, 'one')</span><br><span class="line"></span><br><span class="line">const original = &#123;</span><br><span class="line">  name: <span class="string">'gioia'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>()]: <span class="string">'symbol prop'</span>,</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(<span class="string">'symbol value'</span>),</span><br><span class="line">  friends: [&#123;</span><br><span class="line">    name: <span class="string">'xkld'</span>,</span><br><span class="line">  &#125;, <span class="string">'cln'</span>],</span><br><span class="line">  dress: &#123;</span><br><span class="line">    pants: &#123;</span><br><span class="line">      color: <span class="string">'black'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    shirts: &#123;</span><br><span class="line">      colors: [<span class="string">'blue'</span>, <span class="string">'white'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  map: map,</span><br><span class="line">  <span class="keyword">set</span>: <span class="keyword">set</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const copy = deepClone(original)</span><br><span class="line">console.log(copy)</span><br><span class="line">console.log(copy.sym === original.sym)</span><br><span class="line">console.log(copy.friends === original.friends)</span><br><span class="line">console.log(copy.map === original.map)</span><br></pre></td></tr></table></figure></div><div class="tab-pane" id="[test]-2"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">'gioia'</span>,</span><br><span class="line">  getName: [<span class="built_in">Function</span>: getName],</span><br><span class="line">  sym: <span class="built_in">Symbol</span>(symbol value),</span><br><span class="line">  friends: [ &#123; <span class="attr">name</span>: <span class="string">'xkld'</span> &#125;, <span class="string">'cln'</span> ],</span><br><span class="line">  dress: &#123; <span class="attr">pants</span>: &#123; <span class="attr">color</span>: <span class="string">'black'</span> &#125;, <span class="attr">shirts</span>: &#123; <span class="attr">colors</span>: [ <span class="string">'blue'</span>, <span class="string">'white'</span> ] &#125; &#125;,</span><br><span class="line">  map: <span class="built_in">Map</span> &#123; <span class="number">0</span> =&gt; <span class="string">'zero'</span>, <span class="number">1</span> =&gt; <span class="string">'one'</span> &#125;,</span><br><span class="line">  <span class="keyword">set</span>: Set &#123; <span class="string">'gioia'</span>, <span class="string">'me'</span> &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>()]: <span class="string">'symbol prop'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></div></div></div>

<h1 id="7-解决循环引用"><a href="#7-解决循环引用" class="headerlink" title="7. 解决循环引用"></a>7. 解决循环引用</h1><p>以上我们已经初步实现了一个深拷贝了。但是在循环引用的场景下，会出现栈溢出的现象。<br>例如 <code>original.circle = original</code> 这种情况，我们要是还递归地赋值的话，就永远也没有尽头🥱<br>解决办法就是，看看我们要拷贝的对象之前有没有处理过，有的话就直接引用就行了；没有的话再进行赋值并记录在案。你可以选择很多存储方案，像 Map，只要能记录键值就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基本类型</span></span><br><span class="line">    <span class="keyword">if</span> (!isObject(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isArr = <span class="built_in">Array</span>.isArray(value)</span><br><span class="line">    <span class="keyword">const</span> tag = getTag(value)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        result = initCloneArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> isFunc = <span class="keyword">typeof</span> value === <span class="string">'function'</span></span><br><span class="line">        <span class="comment">// 函数</span></span><br><span class="line">        <span class="keyword">if</span> (isFunc) &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 对象或 arguments</span></span><br><span class="line">        <span class="keyword">if</span> (tag == <span class="string">'[object Object]'</span> || tag == <span class="string">'[object Arguments]'</span>) &#123;</span><br><span class="line">            result = initCloneObject(value)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 特殊对象的初始化</span></span><br><span class="line">            result = initCloneByTag(value, tag)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查循环引用并返回其对应的拷贝</span></span><br><span class="line">    cache || (cache = <span class="keyword">new</span> <span class="built_in">Map</span>())</span><br><span class="line">    <span class="keyword">const</span> cached = cache.get(value)</span><br><span class="line">    <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached</span><br><span class="line">    &#125;</span><br><span class="line">    cache.set(value, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Map 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (tag === mapTag) &#123;</span><br><span class="line">        value.forEach(<span class="function">(<span class="params">subValue, key</span>) =&gt;</span> &#123;</span><br><span class="line">            result.set(key, deepClone(subValue))</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set 赋值</span></span><br><span class="line">    <span class="keyword">if</span> (tag === setTag) &#123;</span><br><span class="line">        value.forEach(<span class="function">(<span class="params">subValue</span>) =&gt;</span> &#123;</span><br><span class="line">            result.add(deepClone(subValue))</span><br><span class="line">        &#125;)</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isArr) &#123;</span><br><span class="line">        <span class="comment">// 数组赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; value.length; i++) &#123;</span><br><span class="line">            result[i] = deepClone(value[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对象赋值</span></span><br><span class="line">        <span class="built_in">Object</span>.keys(<span class="built_in">Object</span>(value)).forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">            result[k] = deepClone(value[k])</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> propertyIsEnumerable = <span class="built_in">Object</span>.prototype.propertyIsEnumerable</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 过滤掉不可枚举的 Symbol 属性并赋值</span></span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertySymbols(value)</span><br><span class="line">            .filter(<span class="function">(<span class="params">symbol</span>) =&gt;</span> propertyIsEnumerable.call(value, symbol))</span><br><span class="line">            .forEach(<span class="function"><span class="params">k</span> =&gt;</span> &#123;</span><br><span class="line">                result[k] = deepClone(value[k])</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>WIP:讲讲我理解的原型</title>
    <url>/2020/05/05/prototype/</url>
    <content><![CDATA[<h1 id="1-原型"><a href="#1-原型" class="headerlink" title="1. 原型"></a>1. 原型</h1><p>我们应该相对独立地来看原型这个概念。<br>很多人会把原型看得很复杂，实际上它只是【能给其它对象提供共享属性的对象】。<br>好比郭德纲和郭麒麟。首先这俩都是人（对象），其次郭德纲给郭麒麟提供了相声教学等“共享属性”，所以郭德纲是一个“原型”。  </p>
<a id="more"></a>

<h2 id="1-1-隐式引用"><a href="#1-1-隐式引用" class="headerlink" title="1.1 隐式引用"></a>1.1 隐式引用</h2><ul>
<li>在许多浏览器中，我们可以通过对象的 <code>__proto__</code>属性来访问该对象的原型。<br>（关于 <code>__proto__</code> 的历史问题我不展开讲了，有兴趣的可以看看第一篇参考文章。）<br>还是用郭德纲郭麒麟来举例子。我们假装郭德纲的儿子们关系网里都有名字叫<code>__爸爸__</code>的人，指向的是郭德纲。那我们访问 <code>郭麒麟.__爸爸__</code>不就可以找到郭德纲了嘛？！  </li>
<li>我们可以通过设置对象的 <code>__proto__</code> 来直接设置原型<br>这就好像郭德纲现在又生了个儿子，他需要在户口本上加上一些信息： <code>新儿子.__爸爸__ = 郭德纲</code></li>
</ul>
<h1 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h1><blockquote>
<p>对于使用过基于类的语言 (如 Java 或 C++) 的开发人员来说，JavaScript 有点令人困惑，因为它是动态的，并且本身不提供一个 class 实现。（在 ES2015/ES6 中引入了 class 关键字，但那只是语法糖，JavaScript 仍然是基于原型的）。  </p>
<p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 <code>__proto__</code>）指向它的构造函数的原型对象（prototype ）。  </p>
<p>(来自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">MDN</a>)</p>
</blockquote>
<p>简单来说，继承意味着“爸爸有的我也有！”。而这一点在 JS 中是通过原型来实现的。  </p>
<h2 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h2><h3 id="2-1-1-显式继承"><a href="#2-1-1-显式继承" class="headerlink" title="2.1.1 显式继承"></a>2.1.1 显式继承</h3><p>既然继承是两个对象之间的事情，那么我们手动给对象设置原型就可以实现继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> gdg = &#123; </span><br><span class="line">    <span class="string">'说相声'</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'我会说相声'</span>)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> gql = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动设置“__proto__”</span></span><br><span class="line">gql.__proto__ = gdg</span><br><span class="line"></span><br><span class="line"><span class="comment">// 爸爸的“说相声”我也有！</span></span><br><span class="line">gql[<span class="string">'说相声'</span>]()</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-隐式继承（构造函数继承）"><a href="#2-1-2-隐式继承（构造函数继承）" class="headerlink" title="2.1.2 隐式继承（构造函数继承）"></a>2.1.2 隐式继承（构造函数继承）</h3><p>显示继承要求我们有 2 个对象，一个对象作为另一个对象的原型。  </p>
<p>但隐式继承不用手动新建一个原型对象，只需通过“构造函数”就能快速实现继承。不过这原理还是<code>__proto__</code>，只不过它悄咪咪给你操作好了，我们使用的时候无痛当爹，察觉不出来而已。  </p>
<p><strong>每个函数，都默认有一个原型</strong>，可以通过 <code>function.prototype</code> 访问到，当我们使用 <code>new</code> 调用构造函数时，就默认继承了这个原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> gdg = <span class="keyword">new</span> Person(<span class="string">'郭德纲'</span>, <span class="number">50</span>) <span class="comment">// 自动继承了Person.prototype</span></span><br></pre></td></tr></table></figure>

<p>我记得我有很长一段时间搞不清楚 <code>prototype</code> 和 <code>__proto__</code>。实际上继承本质上是两个对象之间的关系，中间可以没有构造函数。我们加上 <code>Person</code> 这个函数，但最终我们要用到的是 <code>Person.prototype</code> 这个对象。<br>这就好像 <code>郭麒麟.__爸爸__ = 郭麒麟妈妈.老公</code>（<code>gql.__proto__ = GQLMM.prototype</code>）<br>因此，隐式继承就是妈妈生了一个孩子，<code>生的孩子.__爸爸__ = 妈妈.老公</code>；显示继承有点像直接抱养一个孩子，直接把<code>儿子.__爸爸__</code>改掉就行了  </p>
<p>另外，每个函数的 <code>prototype</code> 也是一个对象，既然是对象就有<code>__proto__</code>，这个属性是默认指向 <code>Object.prototype</code> 的。也就是说 <code>func.prototype.__proto__ === Object.prototype</code>。  </p>
<p>有一道常见的面试题是“new 操作符做了什么工作”。实际上 new 背后的工作和显式继承的思路是一样的。我们尝试用显式继承的思路来写一个 <code>new</code>。大概是按以下三步走：1. 新建对象；2. 手动设置该新对象的<code>__proto__</code>为<code>构造函数.protptype</code>；3. 返回对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">	<span class="comment">// 获得构造函数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">	<span class="comment">// 链接到原型</span></span><br><span class="line">    obj.__proto__ = Con.prototype;</span><br><span class="line">	<span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">	<span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然 new 还是有别的特性的，以上代码只是最基础的。关于 new 操作符可能之后还会再展开写一篇文章。</p>
<h2 id="2-2-方法"><a href="#2-2-方法" class="headerlink" title="2.2 方法"></a>2.2 方法</h2><p>下面要说的继承的方法，其实基本是以显示继承和隐式调用的思想为基础的。以下方法按照 《Javascript 高级程序设计》一书分类。  </p>
<h3 id="2-2-1-原型链"><a href="#2-2-1-原型链" class="headerlink" title="2.2.1 原型链"></a>2.2.1 原型链</h3><p>这个实际上用的是隐式继承的方法  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关键在这里，SubType.prototype 继承了 SuperType.prototype。</span></span><br><span class="line"><span class="comment">// 如果按照郭德纲和郭麒麟的思路。那么 SubType 相当于郭麒麟老婆，SuperType 相当于郭德纲老婆。</span></span><br><span class="line"><span class="comment">// 这个语句就相当于`郭麒麟老婆.老公 = 郭德纲老婆新生一个孩子`。所以这行语句实际上是让郭麒麟和郭德纲之间产生父子关系</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 instance 就是郭麒麟儿子，也是郭德纲孙子</span></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance.getSuperValue());</span><br><span class="line"><span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/prototype.png" alt="image-20200527234026678"></p>
<h4 id="2-2-1-1-问题"><a href="#2-2-1-1-问题" class="headerlink" title="2.2.1.1 问题"></a>2.2.1.1 问题</h4><blockquote>
<p>原型链虽然很强大，可以用它来实现继承，但它也存在一些问题。其中，最主要的问题来自包含引 用类型值的原型。包含引用类型值的原型属性会被所有实例共享;而这也正是为什么要在构造函数中，而不是在原型对象中定义属性的原因。在通过原型来实现继承时，原 型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。</p>
<p>来自《Javascript 高级程序设计》</p>
</blockquote>
<h3 id="2-2-2-借用构造函数"><a href="#2-2-2-借用构造函数" class="headerlink" title="2.2.2 借用构造函数"></a>2.2.2 借用构造函数</h3><p>关键在“借用”，我们在子构造函数中调用父构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承了 SuperType</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(); </span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>

<p>这个和我们之前说的显示、隐式都不一样，他没有涉及到<code>__proto__</code>的变化。但确实实现了 SubType 实例中有 SuperType 相关的内容。通过使用 call()方法(或 apply()方法 也可以)，我们实际上是在(未来将要)新创建的 SubType 实例的环境下调用了 SuperType 构造函数。 这样一来，就会在新 SubType 对象上执行 SuperType()函数中定义的所有对象初始化代码。结果， SubType 的每个实例就都会具有自己的 colors 属性的副本了。</p>
<h4 id="2-2-2-1-问题"><a href="#2-2-2-1-问题" class="headerlink" title="2.2.2.1 问题"></a>2.2.2.1 问题</h4><blockquote>
<p> 如果仅仅是借用构造函数，那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定 义，因此函数复用就无从谈起了。而且，在超类型的原型中定义的方法，对子类型而言也是不可见的，结 果所有类型都只能使用构造函数模式。考虑到这些问题，借用构造函数的技术也是很少单独使用的</p>
<p>来自《Javascript 高级程序设计》</p>
</blockquote>
<h3 id="2-2-3-组合继承"><a href="#2-2-3-组合继承" class="headerlink" title="2.2.3 组合继承"></a>2.2.3 组合继承</h3><p>结合前两种继承方法。用原型链去继承原型上一些共享的属性/方法，用构造函数来初始化实例属性。</p>
<h3 id="2-2-4-原型式继承"><a href="#2-2-4-原型式继承" class="headerlink" title="2.2.4 原型式继承"></a>2.2.4 原型式继承</h3><p>这个关键就是基于已有的对象创建新对象。我们可以用显式也可以用隐式。</p>
<p>先看看显示继承：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">	<span class="comment">// 链接到原型</span></span><br><span class="line">    obj.__proto__ = prototype;</span><br><span class="line">	<span class="comment">// 返回对象</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是和之前写的“new”特别像？？改巴改巴就变成隐式继承了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params">prototype</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = prototype</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ECMAScript 5 新增了 Object.create() 方法用于原型式继承。在没有必要兴师动众地创建构造函数，而只想让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的</p>
<h3 id="2-2-5-寄生式继承"><a href="#2-2-5-寄生式继承" class="headerlink" title="2.2.5 寄生式继承"></a>2.2.5 寄生式继承</h3><p>这个寄生式继承，我理解就是原型式继承上再加点东西。我推荐和接下来的寄生组合式继承联系起来看。</p>
<h3 id="2-2-6-寄生组合式继承"><a href="#2-2-6-寄生组合式继承" class="headerlink" title="2.2.6 寄生组合式继承"></a>2.2.6 寄生组合式继承</h3><p>顾名思义，寄生组合式继承=寄生式继承+组合继承。为什么要有寄生组合式继承呢？明明其他方法已经很香了。因为它<strong>解决了组合继承中调用2次构造函数的问题</strong>。</p>
<p>当我们在讨论 2 个类（当然，JS 中就是个函数）之间的继承时，回顾我们之前提到的 5 种方法。首先不适合的是原型式继承，因为它适用于 2 个对象之间。其次原型链和借用构造函数各自都有一些缺点，组合继承结合了这两者，但它也有个缺点就是会调用 2 次父类的构造函数。那么“寄生组合式继承”就是通过寄生式继承的方法来解决了组合继承的这个缺点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寄生式继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 原型式继承</span></span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype); </span><br><span class="line">  <span class="comment">// 再加点东西</span></span><br><span class="line">  prototype.constructor = subType;</span><br><span class="line">  <span class="comment">// 原型链</span></span><br><span class="line">  subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合继承=原型链+借用构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 调用父类构造函数</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br></pre></td></tr></table></figure>




<h1 id="3-Object-prototype"><a href="#3-Object-prototype" class="headerlink" title="3. Object.prototype"></a>3. <code>Object.prototype</code></h1><p>这是一个十分特殊的对象</p>
<ol>
<li>我们之前说过每个函数都默认有原型的，那么这个就是 <code>Object</code> 函数的原型</li>
<li>这个是 JS 引擎在最开始定义的一个对象。我们可以把它想像成女娲，那么自然   <ol>
<li>女娲是没有原型的，即 <code>Object.prototype.__proto__ === null</code></li>
<li>所有没爸没妈的孩子都当作女娲的孩子。 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普普通通一对象</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">'没爸没妈'</span> &#125;</span><br><span class="line">a.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>




</li>
</ol>
</li>
</ol>
<h1 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4. 原型链"></a>4. 原型链</h1><p>我们已经知道了，每个对象在【给其它对象提供共享属性】时就是原型的，且两者之前是通过 <code>__proto__</code> 来隐式地关联起来的。那么假设有 <code>A.__proto__ = B</code>，B 虽然是 A 的原型，但它自身也可以有原型，也就是 <code>B.__proto__ = C</code>。如下图</p>
<pre class="mermaid">graph LR
A[A] --> |__proto__|B[B]
B --> |__proto__|C[C]
C --> |__proto__|D[...]
D --> |__proto__|E[Object.prototype]
E --> |__proto__|F[null]</pre>
<p>这条链一直下去的话，最终会指向 <code>Object.prototype</code></p>
<h2 id="4-1-属性查找"><a href="#4-1-属性查找" class="headerlink" title="4.1 属性查找"></a>4.1 属性查找</h2><p>问：假设“报菜名”是老郭家的独门绝技，现在郭麒麟想学，该怎么办？<br>答：1. 郭麒麟已经会了，那就自己再复习下；2.郭麒麟不会，那问他爸；3. 他爸也不会，那问他爷爷</p>
<p>同理。当我们访问对象的属性时，也会沿着原型链一直查找</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>如果你看完了文章还是一团乱麻，那么我自己总结了一些要点帮助记忆和理解</p>
<ol>
<li>所有对象都有 <code>__proto__</code></li>
<li>所有函数都默认有 <code>prototype</code></li>
<li>函数也是对象，所以有 <code>__proto__</code></li>
<li>所有函数都继承自 <code>Function</code></li>
</ol>
<!-- TODO -->

<h1 id="6-参考文章"><a href="#6-参考文章" class="headerlink" title="6. 参考文章"></a>6. 参考文章</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/1UDILezroK5wrcK-Z5bHOg">深入理解 JavaScript 原型</a></li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
        <tag>原型</tag>
      </tags>
  </entry>
</search>
